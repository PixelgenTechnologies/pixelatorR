% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/local_G.R
\name{local_G}
\alias{local_G}
\title{Calculate Local G}
\usage{
local_G(
  g,
  counts,
  k = 1,
  W = NULL,
  use_weights = TRUE,
  normalize_counts = TRUE,
  type = c("gi", "gstari"),
  return_p_vals = FALSE,
  p_adjust_method = "BH",
  alternative = c("two.sided", "less", "greater"),
  ...
)
}
\arguments{
\item{g}{A \code{tbl_graph} object representing an MPX component}

\item{counts}{A \code{dgCMatrix} (sparse matrix) with node marker counts. Raw counts
are recommended.}

\item{k}{\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}} An integer value specifying the
distance from each node where additional edges are added to expand the neighborhood from each node. E.g.
with \code{k = 2}, each node will additionally be connected with all neighbors
of the nodes their original neighborhood. With \code{k = 1} (default), only
the adjacent neighbors will be used.}

\item{W}{A \code{dgCMatrix} (sparse matrix) with edge weights. If not provided,
the function will use the adjacency matrix of the graph to compute weights.}

\item{use_weights}{Logical indicating whether to use edge weights. See section
\strong{weights} for details.}

\item{normalize_counts}{Logical indicating whether to normalize the counts. If
\code{TRUE}, the counts within each node are converted to proportions.}

\item{type}{One of "gstari" or "gi". See details below for more information.}

\item{return_p_vals}{Compute and return p-values for the local G scores. The
p values are also adjusted for multiple testing per marker.}

\item{p_adjust_method}{Method to use for multiple testing adjustment. See \code{\link{p.adjust}}
for details.}

\item{alternative}{a character string specifying the alternative hypothesis,
must be one of "two.sided" (default), "greater" or "less".}

\item{...}{Additional arguments passed from other methods.}
}
\value{
A matrix with local G scores or a list with the following items:
\itemize{
\item{gi_mat: A matrix with local G scores}
\item{gi_p_mat: A matrix with p-values (if \code{return_p_vals = TRUE})}
\item{gi_p_adj_mat: A matrix with adjusted p-values (if \code{return_p_vals = TRUE})}
}
}
\description{
Local G is a metric that measures spatial association of some numerical node feature.
The metric can for instance be used to detect hot spots for protein markers in a graph, where nodes
that are close to each other have similar marker count values. The metric is a Z-score that
measures the deviation of the observed local marker expression from the expected marker
expression under the null hypothesis of no spatial association. The sign of the score
indicates whether the observed marker counts are higher or lower than expected
and can therefore be used to identify hot and/or cold spots.
}
\details{
The observed local marker expression for a node is computed by aggregating the weighted marker
expression within its local neighborhood. The local G metric is largely influenced by the choice
of edge weights (see section on weights below) and the size of the local neighborhood \code{k}.
The method implemented here uses incoming transition probabilities for a k-step random walk as
edge weights. By increasing \code{k}, the local neighborhood of each node is expanded, increasing
the "smoothing effect" of the metric, which can be useful to increase the scale of spatial association.

Local G can also be useful for more interpretative visualization of polarized marker expression,
as it enhances spatial trends across neighborhoods in the graph, even if the marker counts in
individual nodes are sparse.
}
\section{\eqn{G_{i}} ("gi")}{

Definition of local G (Getis and Ord 1996, p. 263, equation 14.2):
\deqn{
Z(G_i)=\dfrac{[\sum_{j=1}^{n}w_{i,j}x_j]-[\sum_{j=1}^{n}w_{i,j}\bar x_i]}
{s_i\{[n\sum_{j=1}^{n}w_{i,j}^2-(\sum_{j=1}^{n}w_{i,j})^2]/(n-1)\}^{1/2}},\forall j\neq i
}
\cr
where \deqn{s_i = \sqrt{((\sum_{j=1}^{n}x_j^2)/(n-1))-[\bar x_i]^2},\forall j\neq i}
and \deqn{\bar x_i=(\sum_{j=1}^{n}x_j)/(n-1),\forall j\neq i}
The left numerator corresponds to \eqn{G_i}, the right to \eqn{E(G_i)},
and the denominator to \eqn{Var(G_i)}.
}

\section{\eqn{G_{i}^{*}} ("gstari")}{

In the equation for \eqn{G_{i}}, the condition that \eqn{i\neq j} is central. \eqn{G_i^*}
relaxes this constraint, by including \eqn{i} as a neighbor of itself This local measure
is expressed as (Getis and Ord 1996, p. 263, equation 14.3):
\deqn{
Z(G_i^*)=\dfrac{[\sum_{j=1}^{n}w_{i,j}x_j]-[(\sum_{j=1}^{n}w_{i,j})\bar x^*]}
{s^*\{[(n-1)\sum_{j=1}^{n}w_{i,j}^2-(\sum_{j=1}^{n}w_{i,j})^2]/(n-2)\}^{1/2}},\forall j
}
\cr
where \deqn{s^* = \sqrt{((\sum_{j=1}^{n}x_j^2)/n)-\bar x_i^{*2}}}
and \deqn{\bar x_i^*=(\sum_{j=1}^{n}x_j)/n,\forall j}
}

\section{weights}{

Weights are calculated for node pairs if \code{use_weights = TRUE}. For an undirected
path between nodes \eqn{i \sim j}, the weight is defined as the transition probability
for a k-step walk between \eqn{i} and \eqn{j}. This helps normalizing the contribution
by each neighbor in a manner that reduces the influence of high degree nodes. The strategy
rests on the assumption that node degree correlates strongly with the node marker count.

In practice, the weights are calculated by normalizing the adjacency matrix of the graph
such that each row sums to 1 (also known as the stochastic matrix). By multiplying the
transpose of the stochastic matrix with the count matrix, we obtain a "lag matrix" with the weighted
marker expression for each node neighborhood which is leveraged in the computation of local G.

When using \code{k > 1}, the k'th power of the stochastic matrix is used instead. In this
case, the transition probabilities are calculated for a k-step random walk.
Since the random walker can reach a larger neighborhood when \code{k > 1}, we will
also include information about the marker expression for nodes that are more than 1 steps
away from the center node. Moreover, when \code{k > 1}, the weights for \eqn{i \sim i}
(self-loops) can become positive. These transitions are not allowed in the calculation of
\eqn{G_i} and are therefore set to 0, and the remaining transition probabilities are normalized
to 1 within each node neighborhood. This weighing scheme is ignored if \code{W} is provided.
}

\examples{
library(dplyr)
# Load example data as a Seurat object
pxl_file <- system.file("extdata/five_cells",
                        "five_cells.pxl",
                        package = "pixelatorR")
seur_obj <- ReadMPX_Seurat(pxl_file) \%>\%
  LoadCellGraphs(cells = colnames(.)[1]) \%>\%
  ComputeLayout(layout_method = "pmds", dim = 3)
cg <- CellGraphs(seur_obj)[[1]]
g <- CellGraphData(cg, "cellgraph")
counts <- CellGraphData(cg, "counts")
xyz <- CellGraphData(cg, "layout")[["pmds"]]

# Compute local G scores
gi_mat <- local_G(g, counts = counts)

# Visualize
scores <- gi_mat[, "CD3E"]
max_abs_val <- max(abs(scores))
node_colors <-
  scales::col_quantile(
    domain = c(-max_abs_val, max_abs_val),
    palette = "RdBu",
    probs = seq(0, 0.99, length.out = 11),
    reverse = TRUE
  )(scores)
plotly::plot_ly(
  xyz,
  x = ~x,
  y = ~y,
  z = ~z,
  type = "scatter3d",
  mode = "markers",
  marker = list(size = 5,
                color = node_colors)
)

}
\references{
Bivand, R.S., Wong, D.W.S. Comparing implementations of global and
local indicators of spatial association. TEST 27, 716â€“748 (2018).
\url{https://doi.org/10.1007/s11749-018-0599-x}
}
