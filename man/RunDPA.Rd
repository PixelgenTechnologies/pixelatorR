% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generics.R, R/differential_polarity_analysis.R
\name{RunDPA}
\alias{RunDPA}
\alias{RunDPA.data.frame}
\alias{RunDPA.Seurat}
\title{Differential analysis (polarization)}
\usage{
RunDPA(object, ...)

\method{RunDPA}{data.frame}(
  object,
  contrast_column,
  reference,
  targets = NULL,
  group_vars = NULL,
  polarity_metric = c("morans_z", "morans_i"),
  min_n_obs = 0,
  cl = NULL,
  alternative = c("two.sided", "less", "greater"),
  conf_int = TRUE,
  p_adjust_method = c("bonferroni", "holm", "hochberg", "hommel", "BH", "BY", "fdr"),
  verbose = TRUE,
  ...
)

\method{RunDPA}{Seurat}(
  object,
  contrast_column,
  reference,
  targets = NULL,
  assay = NULL,
  group_vars = NULL,
  polarity_metric = c("morans_z", "morans_i"),
  min_n_obs = 0,
  cl = NULL,
  alternative = c("two.sided", "less", "greater"),
  conf_int = TRUE,
  p_adjust_method = c("bonferroni", "holm", "hochberg", "hommel", "BH", "BY", "fdr"),
  verbose = TRUE,
  ...
)
}
\arguments{
\item{object}{An object containing polarization scores}

\item{...}{Not yet implemented}

\item{contrast_column}{The name of the column where the group labels are stored.
This column must include \code{target} and \code{reference}.}

\item{reference}{The name of the reference group}

\item{targets}{The name of the target groups. These groups will be compared to the reference group.
If the value is set to \code{NULL} (default), all groups available in \code{contrast_column} will
be compared to the reference group.}

\item{group_vars}{An optional character vector with column names to split the tests by.}

\item{polarity_metric}{The polarity metric to use. Currently, you can select one of "morans_z" (default)
or "morans_i".}

\item{min_n_obs}{Minimum number of observations allowed in a group. Target groups with less
observations than \code{min_n_obs} will be skipped.}

\item{cl}{A cluster object created by makeCluster, or an integer
to indicate number of child-processes (integer values are ignored
on Windows) for parallel evaluations. See Details on performance
in the documentation for \code{pbapply}. The default is NULL,
which means that no parallelization is used.}

\item{alternative}{One of 'two.sided', 'less' or 'greater' (see \code{?wilcox.test} for details)}

\item{conf_int}{Should confidence intervals be computed? (see \code{?wilcox.test} for details)}

\item{p_adjust_method}{One of "bonferroni", "holm", "hochberg", "hommel", "BH", "BY" or "fdr".
(see \code{?p.adjust} for details)}

\item{verbose}{Print messages}

\item{assay}{Name of assay to use}
}
\value{
A \code{tbl_df} object with test results
}
\description{
Runs differential analysis on Moran's Z polarization scores generated with the
\code{Pixelator} data processing pipeline.
}
\details{
If you are working with a \code{Seurat} object containing a \code{\link{CellGraphAssay}},
the polarization scores are accessed directly from the \code{\link{CellGraphAssay}}.
A character vector or factor must be selected with \code{contrast_column} from the
input data (or @meta.data slot from a \code{Seurat} object) which holds the groups
to run the test for. The \code{target} and \code{reference} parameters should refer
to the names of the two groups used for the comparison and these names should be present in
the \code{contrast_column}.
}
\section{Additional groups}{

The test is always computed between \code{target} and \code{reference}, but it is possible
to add additional grouping variables with \code{group_vars}. If \code{group_vars} is used,
the test will be computed within each combination of groups. For instance, if we have annotated
cells into cell type populations across two conditions defined by \code{target} and \code{reference},
we can pass the name of a cell annotation column with \code{group_vars} to run the test
for each cell type.
}

\examples{
library(pixelatorR)
library(dplyr)

pxl_file <- system.file("extdata/five_cells",
                        "five_cells.pxl",
                        package = "pixelatorR")

# Load polarization scores
polarization_table1 <- polarization_table2 <- ReadMPX_polarization(pxl_file)
polarization_table1$sample <- "Sample1"
polarization_table2$sample <- "Sample2"
polarization_table_merged <-  bind_rows(polarization_table1, polarization_table2)

# Run DPA using table as input
dpa_markers <- RunDPA(polarization_table_merged, contrast_column = "sample",
                      target = "Sample1", reference = "Sample2")
dpa_markers

# Seurat objects
seur1 <- seur2 <- ReadMPX_Seurat(pxl_file)
seur1$sample <- "Sample1"
seur2$sample <- "Sample2"
seur_merged <- merge(seur1, seur2, add.cell.ids = c("A", "B"))

# Run DPA
dpa_markers <- RunDPA(seur_merged, contrast_column = "sample",
                      target = "Sample1", reference = "Sample2")
dpa_markers

}
\seealso{
Other DA-methods: 
\code{\link{RunDCA}()}
}
\concept{DA}
\concept{DA-methods}
